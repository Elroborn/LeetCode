# LeetCode 1. Two Sum 两数之和

标签： Leetcode

---
## 题目描述   

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的两个整数。   

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。   

示例:  

给定 nums = [2, 11, 7, 15], target =  9  

因为 nums[0] + nums[2] = 2 + 7 = 9
所以返回 [0, 2]    

## 解题思路   

### 1.暴力法   

使用两层for循环，找出两个和为target的元素，然后记录其位置返回即可，但是在LeetCode中使用python可能会出现超时的线现象，所以$O(n^2)$时间复杂度不能完成该任务。所以可以考虑空间换时间。  

### 2.哈希表    

#### 2.1  哈希表思想

可以考虑使用一个哈希表（可以用python中字典表示）记录你访问过的元素，比如第一次你访问的是2(位置是0)，那么你可以在字典中添加一条记录：{"target-nums[0]":0}，之所以字典的value用位置是因为最终结果要的是两个位置，字典的key用target-nums[0]的原因是我们记录下当前元素，以及当前元素需要配对的元素，这样我们在遍历数组的时候，每次检查一下遍历到的元素是不是在字典中（key），如果在字典中那么说明之前我们遍历到了一个需要当前元素配对的元素，并且字典中也存储了那个元素的位置，所以成功得到结果。  

#### 2.2 举个栗子  

初始情况：
|nums|2|11|7|15|
|--|--|--|--|--|  
target = 9
d ={ }  

|i|d|
|--|--|
|0|{7:0}(其中 7 = target - nums[0])说明2需要一个7配对  
|1|{7:0,-2:1} 说明11需要一个-2配对|
|2|{7:0，-2:1} 因为7在字典的key中，说明7之前被0位置的元素需要了，所以得到结果，返回[d["7"],2]   

### 3.python代码实现  

    class Solution():
        def twoSum(self, nums, target):
            d = {}
            # enumerate(nums)返回一个元组（位置，值）
            for i, v in enumerate(nums):
                if v in d:
                    return [d[v], i]
                d[target - v] = i    
                
                





